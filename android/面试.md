1、不同场景下activity的生命周期
    activity返回前台 onRestart()、 onStart()、 onResume();
2、数据序列化和反序列化的作用
    数据序列化就是将对象或者数据结构转化成特定的格式，使其可在网络中传输，或者可存储在内存或者文件中。反序列化则是相反的操作，将对象从序列化数据中还原出来。而对象序列化后的数据格式可以是二进制，可以是XML，也可以是JSON等任何格式。对象/数据序列化的重点在于数据的交换和传输
3、mvc、mvp、mvvm

    MVC
    视图层(View)
    一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。
    控制层(Controller)
    Android的控制层的重任通常落在了众多的Activity的肩上。这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Actiivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。
    模型层(Model)
    我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。就是应用程序中二进制的数据。

    MVP
    MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）：
    View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity)
    Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合)
    Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。
    *View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试


5、泛型
    Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合
    Set<?>是个通配符类型，表示只能包含某种未知对象类型的一个集合
    Set则是原生态类型，脱离了泛型系统
    前两种是安全的，最后一种是不安全的

6、接口回调
    实现方式有两种：内部类和接口实现
    1、在需要传递数据的一端定义一个接口，接口里面些需要监听的方法以及参数。

2、定义一个的接口类型的变量存储数据。

3、创建一个公共的方法，让外部调用，并且传递接口类型的参数，给其定义的接口类型的数据初始化。
    
    一、内部类的形式
    /** 
    * 定义一个接口 
    */ 
    public interface  onListener{ 
    void OnListener(String code,String msg); 
    } 
    /** 
    *定义一个变量储存数据 
    */ 
    private onListener listener;  
    /** 
    *提供公共的方法,并且初始化接口类型的数据 
    */ 
    public void setListener( onListener listener){ 
    this.listener = listener; 
    } 

    4、在合适的位置调用接口里面的方法，传递数据。

    /** 
    * 在合适的位置给其调用接口，给其赋值 
    */ 
    if (listener!=null) { 
    listener.OnListener(rtncode,rtnmsg); 
    } 

    5、在需要获取数据的地方，创建对象调方法。

    Print print = new Print(); 
    print.setListener(new PrintTicket.onListener() { 
    @Override 
    public void OnListener(String code, String msg) { 
        //在这里获取数据进行处理 
    } 
    }); 


    二、实现接口的形式

    1、定义一个接口，可以另起包名，或者定义在类里面。

    /** 
    * 定义一个接口 
    */ 
    public interface  onListener{ 
    void OnListener(String code,String msg); 
    } 

    2、在需要传递数据的一端的构造方法对接口进行初始化。

    public Print(OnListener listener) { 
    this.listener = listener; 
    } 

    3、在合适的位置调用接口里面的方法，传递数据。

    /** 
    * 在合适的位置给其调用接口，给其赋值 
    */ 
    if (listener!=null) { 
    listener.OnListener(rtncode,rtnmsg); 
    } 

    4、在需要获取数据的地方创建对象传递参数。

    Print print = new Print(this); 

    这里面的this代指的是当前页面的activity，如果是fragment的话，需要重写onAttach方法对其进行初始化，强制类型转换后获取接口对象。此时在构造方法里面传递接口得数据listener，如下二选一。






