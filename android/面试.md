1、不同场景下activity的生命周期

    activity返回前台 onRestart()、 onStart()、 onResume();
2、数据序列化和反序列化的作用

    数据序列化就是将对象或者数据结构转化成特定的格式，使其可在网络中传输，或者可存储在内存或者文件中。反序列化则是相反的操作，将对象从序列化数据中还原出来。而对象序列化后的数据格式可以是二进制，可以是XML，也可以是JSON等任何格式。对象/数据序列化的重点在于数据的交换和传输
3、mvc、mvp、mvvm

    MVC
    视图层(View)
    一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。
    控制层(Controller)
    Android的控制层的重任通常落在了众多的Activity的肩上。这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Actiivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。
    模型层(Model)
    我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。就是应用程序中二进制的数据。

    MVP
    MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）：
    View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity)
    Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合)
    Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。
    *View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试


5、泛型

    Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合
    Set<?>是个通配符类型，表示只能包含某种未知对象类型的一个集合
    Set则是原生态类型，脱离了泛型系统
    前两种是安全的，最后一种是不安全的

6、接口回调

    实现方式有两种：内部类和接口实现
    1、在需要传递数据的一端定义一个接口，接口里面些需要监听的方法以及参数。
    2、定义一个的接口类型的变量存储数据。
    3、创建一个公共的方法，让外部调用，并且传递接口类型的参数，给其定义的接口类型的数据初始化。
    
    一、内部类的形式
    /** 
    * 定义一个接口 
    */ 
    public interface  onListener{ 
    void OnListener(String code,String msg); 
    } 
    /** 
    *定义一个变量储存数据 
    */ 
    private onListener listener;  
    /** 
    *提供公共的方法,并且初始化接口类型的数据 
    */ 
    public void setListener( onListener listener){ 
    this.listener = listener; 
    } 

    4、在合适的位置调用接口里面的方法，传递数据。

    /** 
    * 在合适的位置给其调用接口，给其赋值 
    */ 
    if (listener!=null) { 
    listener.OnListener(rtncode,rtnmsg); 
    } 

    5、在需要获取数据的地方，创建对象调方法。

    Print print = new Print(); 
    print.setListener(new PrintTicket.onListener() { 
    @Override 
    public void OnListener(String code, String msg) { 
        //在这里获取数据进行处理 
    } 
    }); 


    二、实现接口的形式

    1、定义一个接口，可以另起包名，或者定义在类里面。
    /** 
    * 定义一个接口 
    */ 
    public interface  onListener{ 
    void OnListener(String code,String msg); 
    } 

    2、在需要传递数据的一端的构造方法对接口进行初始化。
    public Print(OnListener listener) { 
    this.listener = listener; 
    } 

    3、在合适的位置调用接口里面的方法，传递数据。
    /** 
    * 在合适的位置给其调用接口，给其赋值 
    */ 
    if (listener!=null) { 
    listener.OnListener(rtncode,rtnmsg); 
    } 

    4、在需要获取数据的地方创建对象传递参数。
    Print print = new Print(this); 
    这里面的this代指的是当前页面的activity，如果是fragment的话，需要重写onAttach方法对其进行初始化，强制类型转换后获取接口对象。此时在构造方法里面传递接口得数据listener，如下二选一。

4、基于Aop的框架设计

    AOP(Aspect-Oriented Programming, 面向切面编程)，是对OOP(Object-Oriented Programming, 面向对象编程)的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（Cross-Cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。

5、AlertDialog和popupwindow的区别

    本质区别在于AlertDialog弹出后，后台还可以做事情；popupwindow弹出后程序会处于等待状态，调用dismiss后，popupwindow退出程序才会继续执行；
    AlertDialog在弹出时点击周边区域，Dialog会消失
    popupwindow在弹出时点击背景不会有什么变化

6、广播的理解

    你的应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。

    普通广播，通过Context.sendBroadcast(Intent myIntent)发送的

    有序广播，通过Context.sendOrderedBroadcast(intent, receiverPermission)发送的，该方法第2个参数决定该广播的级别，级别数值是在 -1000 到 1000 之间 , 值越大 , 发送的优先级越高；广播接收者接收广播时的级别级别（可通过intentfilter中的priority进行设置设为2147483647时优先级最高），同级别接收的先后是随机的， 再到级别低的收到广播，高级别的或同级别先接收到广播的可以通过abortBroadcast()方法截断广播使其他的接收者无法收到该广播，还有其他构造函数

    异步广播，通过Context.sendStickyBroadcast(Intent myIntent)发送的，还有sendStickyOrderedBroadcast(intent, resultReceiver, scheduler,  initialCode, initialData, initialExtras)方法，该方法具有有序广播的特性也有异步广播的特性；发送异步广播要： <uses-permission android:name="android.permission.BROADCAST_STICKY" />权限，接收并处理完Intent后，广播依然存在，直到你调用removeStickyBroadcast(intent)主动把它去掉

    注册方式
    动态注册广播接收器还有一个特点，就是当用来注册的Activity关掉后，广播也就失效了。
    静态注册无需担忧广播接收器是否被关闭,只要设备是开启状态,广播接收器也是打开着的。也就是说哪怕app本身未启动,该app订阅的广播在触发时也会对它起作用

    系统常见广播Intent,如开机启动、电池电量变化、时间改变等广播

    监听广播Intent步骤:

    1>写一个继承BroadCastReceiver的类,重写onReceive()方法,广播接收器仅在它执行这个方法时处于活跃状态。当onReceive()返回后，它即为失活状态,注意:为了保证用户交互过程的流畅,一些费时的操作要放到线程里,如类名SMSBroadcastReceiver

    2>注册该广播接收者,注册有两种方法程序动态注册和AndroidManifest文件中进行静态注册（可理解为系统中注册）如下：
    静态注册,注册的广播，下面的priority表示接收广播的级别"2147483647"为最高优先级
    <receiver android:name=".SMSBroadcastReceiver" >
    　　<intent-filter android:priority = "2147483647" >
    　　　　<action android:name="android.provider.Telephony.SMS_RECEIVED" />
    　　</intent-filter>
    </receiver >

    动态注册，一般在Activity可交互时onResume()内注册BroadcastReceiver
    IntentFilter intentFilter=new IntentFilter("android.provider.Telephony.SMS_RECEIVED");
    registerReceiver(mBatteryInfoReceiver ,intentFilter);
    //反注册
    unregisterReceiver(receiver);

7、如何访问其他应用的sharedpreference

    访问其他应用中的Preference
    如果要访问其他应用中的Preference，必须满足的条件是，要访问的应用的Preference创建时指定了Context.MODE_WORLD_READABLE或者Context.MODE_WORLD_WRITEABLE权限。
    举例，假如有个<package name>为com.wujay.action下面的应用使用了下面语句创建了Preference，getSharedPreferences("wujay", Context.MODE_WORLD_READABLE),

    现在要访问该Preferences:
    首先，需要创建上面的Context,然后通过Context访问Preferences，访问preference时会在应用所在包下的shared_prefs目录找到preference：
    Context otherAppsContext = createPackageContext("com.wujay.action", Context.CONTEXT_IGNORE_SECURITY);
    SharedPreferences sharedPreferences = otherAppsContext.getSharedPreferences("wujay", Context.MODE_WORLD_READABLE);
    String name = sharedPreferences.getString("name", "");
    int age = sharedPreferences.getInt("age", 0);
    如果不通过创建Context访问其他应用的preference，可以以读取xml文件方式直接访问其他应用preference对应的xml文件，如：
    File xmlFile = new File(“/data/data/<package name>/shared_prefs/itcast.xml”);//<package name>应替换成应用的包名。

8、横竖屏切换activity的生命周期

    public class Activity1 extends Activity{  
        public Button mButton;  
        @Override  
        protected void onCreate(Bundle savedInstanceState) {  
            super.onCreate(savedInstanceState);  
            setContentView(R.layout.activity_lifecycle);  
            System.out.println("Activity1----->onCreate");  
        }  
    
        @Override  
        protected void onDestroy() {  
            super.onDestroy();  
            System.out.println("Activity1----->onDestroy");  
        }  
    
        @Override  
        protected void onPause() {  
            super.onPause();  
            System.out.println("Activity1----->onPause");  
        }  
    
        @Override  
        protected void onRestart() {  
            super.onRestart();  
            System.out.println("Activity1----->onRestart");  
        }  
    
        @Override  
        protected void onResume() {  
            super.onResume();  
            System.out.println("Activity1----->onResume");  
        }  
    
        @Override  
        protected void onStart() {  
            super.onStart();  
            System.out.println("Activity1----->onStart");  
        }  
    
        @Override  
        protected void onStop() {  
            super.onStop();  
            System.out.println("Activity1----->onStop");  
        }  
        
        @Override  
        protected void onRestoreInstanceState(Bundle savedInstanceState) {  
            super.onRestoreInstanceState(savedInstanceState);  
            System.out.println("Activity1----->onRestoreInstanceState");  
        }  
      
        @Override  
        protected void onSaveInstanceState(Bundle outState) {  
            super.onSaveInstanceState(outState);  
            System.out.println("Activity1----->onSaveInstanceState");  
        }  
        @Override  
        public void onConfigurationChanged(Configuration newConfig) {  
            super.onConfigurationChanged(newConfig);  
            if(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)  
            {  
                System.out.println("现在是横屏转竖屏");  
            }else if(newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE)  
            {  
                System.out.println("现在是竖屏转横屏");  
            }  
        }  
    }  
      
    当我们设置Activity的android:configChanges属性为orientation或者orientation|keyboardHidden或者不设置这个属性的时候，Logcat输出如下：
    刚刚启动Activity的时候：
    Activity1----->onCreate
    Activity1----->onStart
    Activity1----->onResume
    模拟器中按下Ctrl+F11或者Ctrl+F12由竖屏切换到横屏（横屏切竖屏同理）
    Activity1----->onPause
    Activity1----->onSaveInstanceState
    Activity1----->onStop
    Activity1----->onDestroy
    Activity1----->onCreate
    Activity1----->onStart
    Activity1----->onRestoreInstanceState
    Activity1----->onResume

    当我们设置Activity的android:configChanges属性为orientation|screenSize或者orientation|screenSize|keyboardHidden，Logcat输出如下：

    刚刚启动Activity的时候：
    Activity1----->onCreate
    Activity1----->onStart
    Activity1----->onResume
    模拟器中按下Ctrl+F11或者Ctrl+F12由竖屏切换到横屏：
    现在是竖屏转横屏
    模拟器中按下Ctrl+F11或者Ctrl+F12由横屏切换到竖屏：
    现在是横屏转竖屏
    可以发现在设置了orientation|screenSize属性之后，在进行横竖屏切换的时候调用的方法是onConfigurationChanged，而不会重新加载Activity的各个生命周期；

9、自定义view如何考虑机型适配

    这里要考虑的是屏幕的问题：
    合理使用warp_content，match_parent.
    尽可能的是使用RelativeLayout
    针对不同的机型，使用不同的布局文件放在对应的目录下，android会自动匹配。
    尽量使用点9图片。
    使用与密度无关的像素单位dp，sp
    引入android的百分比布局。
    切图的时候切大分辨率的图，应用到布局当中。在小分辨率的手机上也会有很好的显示效果。

10、android多线程编程

   1、Handler+Thread
   2、AsyncTask

        * 处理单个异步任务简单，可以获取到异步任务的进度
        * 可以通过cancel方法取消还没执行完的AsyncTask
        * 处理多个异步任务代码显得较多
   3、ThreadPoolExecutor 批处理任务

        1. Executors.newFixedThreadPool() 创建一个定长的线程池，每提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化 
        2. Executors.newCachedThreadPool() 创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时， 它可以灵活的添加新的线程，而不会对池的长度作任何限制 3. Executors.newScheduledThreadPool() 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer 4. Executors.newSingleThreadExecutor() 创建一个单线程化的executor，它只创建唯一的worker线程来执行任务
   4、IntentService

11、







